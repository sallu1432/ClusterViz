{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/lib/datasets.ts"],"sourcesContent":["export const DATASETS = {\n  iris: {\n    name: \"Iris\",\n    domain: \"ðŸŒ¸ Botany / Biology\",\n    description: \"A classic dataset in pattern recognition, it contains 3 classes of 50 instances each, where each class refers to a type of iris plant.\",\n    features: [\"sepal length (cm)\", \"sepal width (cm)\", \"petal length (cm)\", \"petal width (cm)\"],\n    feature_definitions: {\n      \"sepal length (cm)\": \"The length of the sepal. Sepals are the green, leaf-like parts of the flower that enclose the bud. This feature is a key indicator of the flower's size.\",\n      \"sepal width (cm)\": \"The width of the sepal. Along with length, this helps differentiate species based on sepal proportions.\",\n      \"petal length (cm)\": \"The length of the petal. Petals are the often brightly colored parts of a flower. Petal dimensions are highly correlated with the specific Iris species.\",\n      \"petal width (cm)\": \"The width of the petal. This is one of the most important features for distinguishing between Iris Setosa, Versicolour, and Virginica.\"\n    }\n  },\n  wine: {\n    name: \"Wine\",\n    domain: \"ðŸ‡ Chemistry / Food Science\",\n    description: \"A dataset containing the results of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars.\",\n    features: [\"alcohol\", \"malic_acid\", \"ash\", \"alcalinity_of_ash\", \"magnesium\", \"total_phenols\", \"flavanoids\", \"nonflavanoid_phenols\", \"proanthocyanins\", \"color_intensity\", \"hue\", \"od280/od315_of_diluted_wines\", \"proline\"],\n    feature_definitions: {\n      \"alcohol\": \"The percentage of alcohol content. This is a primary differentiator for wine types and quality.\",\n      \"malic_acid\": \"A type of acid found in wine that contributes to its tartness. Its concentration varies significantly between grape cultivars.\",\n      \"ash\": \"The mineral content left after evaporation and combustion. It reflects the soil and growing conditions of the grapes.\",\n      \"alcalinity_of_ash\": \"A measure of the alkalinity of the ash, which can indicate the wine's mineral composition.\",\n      \"magnesium\": \"The amount of magnesium, a mineral that can affect the wine's taste and development.\",\n      \"total_phenols\": \"Phenols are chemical compounds that affect the taste, color, and mouthfeel of wine. This is a measure of the total amount.\",\n      \"flavanoids\": \"A specific type of phenol that is a key indicator of a wine's antioxidant properties and is crucial for distinguishing between cultivars.\",\n      \"nonflavanoid_phenols\": \"Other phenolic compounds that contribute to the wine's overall profile.\",\n      \"proanthocyanins\": \"A class of flavonoids that contribute to the wine's astringency and color.\",\n      \"color_intensity\": \"A measure of the depth of the wine's color.\",\n      \"hue\": \"The specific tint of the wine's color, which can range from red to yellow.\",\n      \"od280/od315_of_diluted_wines\": \"A measure of protein concentration, obtained via spectroscopy, which helps differentiate wine types.\",\n      \"proline\": \"An amino acid, the content of which can be an indicator of grape ripeness and quality.\"\n    }\n  },\n  breast_cancer: {\n    name: \"Breast Cancer\",\n    domain: \"ðŸ§¬ Medical / Health\",\n    description: \"A dataset with features computed from a digitized image of a fine needle aspirate (FNA) of a breast mass. They describe characteristics of the cell nuclei present in the image.\",\n    features: [\"mean radius\", \"mean texture\", \"mean perimeter\", \"mean area\", \"mean smoothness\", \"mean compactness\", \"mean concavity\", \"mean concave points\", \"mean symmetry\", \"mean fractal dimension\", \"radius error\", \"texture error\", \"perimeter error\", \"area error\", \"smoothness error\", \"compactness error\", \"concavity error\", \"concave points error\", \"symmetry error\", \"fractal dimension error\", \"worst radius\", \"worst texture\", \"worst perimeter\", \"worst area\", \"worst smoothness\", \"worst compactness\", \"worst concavity\", \"worst concave points\", \"worst symmetry\", \"worst fractal dimension\"],\n    feature_definitions: {\n      \"mean radius\": \"The average of distances from the center to points on the perimeter of the cell nucleus. A primary indicator of tumor size.\",\n      \"mean texture\": \"The standard deviation of gray-scale values in the cell nucleus image. It measures the uniformity of the nucleus's texture.\",\n      \"mean perimeter\": \"The average perimeter of the cell nuclei. Related to size and shape.\",\n      \"mean area\": \"The average area of the cell nuclei. Highly correlated with radius and perimeter.\",\n      \"mean smoothness\": \"The average of local variation in radius lengths. It quantifies the smoothness of the nuclear contour.\",\n      \"mean compactness\": \"Calculated as (perimeter^2 / area - 1.0). It's a measure of the shape of the nucleus; less compact shapes are more irregular.\",\n      \"mean concavity\": \"The severity of concave portions of the nucleus's contour. Irregular, concave contours can be a sign of malignancy.\",\n      \"mean concave points\": \"The number of concave portions of the contour. This feature is highly indicative of malignancy.\",\n      \"mean symmetry\": \"A measure of the symmetry of the cell nucleus. Cancerous cells often exhibit less symmetry.\",\n      \"mean fractal dimension\": \"A measure of the 'coastline approximation' of the nucleus border, which provides a sense of its complexity. More complex borders can be indicative of malignancy.\"\n    }\n  },\n};\n\nexport const LINKAGE_METHODS = ['ward', 'complete', 'average', 'single'];\nexport const DISTANCE_METRICS = ['euclidean', 'manhattan', 'cosine'];\n"],"names":[],"mappings":";;;;;AAAO,MAAM,WAAW;IACtB,MAAM;QACJ,MAAM;QACN,QAAQ;QACR,aAAa;QACb,UAAU;YAAC;YAAqB;YAAoB;YAAqB;SAAmB;QAC5F,qBAAqB;YACnB,qBAAqB;YACrB,oBAAoB;YACpB,qBAAqB;YACrB,oBAAoB;QACtB;IACF;IACA,MAAM;QACJ,MAAM;QACN,QAAQ;QACR,aAAa;QACb,UAAU;YAAC;YAAW;YAAc;YAAO;YAAqB;YAAa;YAAiB;YAAc;YAAwB;YAAmB;YAAmB;YAAO;YAAgC;SAAU;QAC3N,qBAAqB;YACnB,WAAW;YACX,cAAc;YACd,OAAO;YACP,qBAAqB;YACrB,aAAa;YACb,iBAAiB;YACjB,cAAc;YACd,wBAAwB;YACxB,mBAAmB;YACnB,mBAAmB;YACnB,OAAO;YACP,gCAAgC;YAChC,WAAW;QACb;IACF;IACA,eAAe;QACb,MAAM;QACN,QAAQ;QACR,aAAa;QACb,UAAU;YAAC;YAAe;YAAgB;YAAkB;YAAa;YAAmB;YAAoB;YAAkB;YAAuB;YAAiB;YAA0B;YAAgB;YAAiB;YAAmB;YAAc;YAAoB;YAAqB;YAAmB;YAAwB;YAAkB;YAA2B;YAAgB;YAAiB;YAAmB;YAAc;YAAoB;YAAqB;YAAmB;YAAwB;YAAkB;SAA0B;QACzkB,qBAAqB;YACnB,eAAe;YACf,gBAAgB;YAChB,kBAAkB;YAClB,aAAa;YACb,mBAAmB;YACnB,oBAAoB;YACpB,kBAAkB;YAClB,uBAAuB;YACvB,iBAAiB;YACjB,0BAA0B;QAC5B;IACF;AACF;AAEO,MAAM,kBAAkB;IAAC;IAAQ;IAAY;IAAW;CAAS;AACjE,MAAM,mBAAmB;IAAC;IAAa;IAAa;CAAS","debugId":null}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/lib/clustering-simulation.ts"],"sourcesContent":["import { ClusteringResults } from \"@/types\";\nimport { DATASETS } from \"./datasets\";\n\ntype SimulationParams = {\n  dataset: keyof typeof DATASETS;\n  nClusters: number;\n  features: string[];\n};\n\n// Helper functions to generate mock data\nconst random = (min: number, max: number) => Math.random() * (max - min) + min;\nconst randomInt = (min: number, max: number) => Math.floor(random(min, max));\n\nconst generateScatterData = (nSamples: number, nClusters: number, nFeatures: number): ClusteringResults['scatter_data_2d'] => {\n  const points = [];\n  const clusterCenters = Array.from({ length: nClusters }, () => ({\n    x: random(-10, 10),\n    y: random(-10, 10),\n  }));\n\n  for (let i = 0; i < nSamples; i++) {\n    const clusterIndex = i % nClusters;\n    points.push({\n      x: clusterCenters[clusterIndex].x + random(-2, 2),\n      y: clusterCenters[clusterIndex].y + random(-2, 2),\n      cluster: clusterIndex,\n      sample_index: i,\n    });\n  }\n  return points;\n};\n\nconst generateDendrogramData = (nSamples: number, nClusters: number): ClusteringResults['dendrogram'] => {\n    const nodes: { [key: number]: { x: number; y: number } } = {};\n    const links: ClusteringResults['dendrogram']['links'] = [];\n    const clusterThreshold = random(0.5, 2.5);\n\n    // Create leaf nodes\n    for (let i = 0; i < nSamples; i++) {\n        nodes[i] = { x: i, y: 0 };\n    }\n\n    let mergeCount = nSamples;\n    let availableNodes = Array.from({ length: nSamples }, (_, i) => i);\n\n    while (availableNodes.length > 1) {\n        const idx1 = randomInt(0, availableNodes.length);\n        const node1Id = availableNodes[idx1];\n        availableNodes.splice(idx1, 1);\n        \n        const idx2 = randomInt(0, availableNodes.length);\n        const node2Id = availableNodes[idx2];\n        availableNodes.splice(idx2, 1);\n\n        const node1 = nodes[node1Id];\n        const node2 = nodes[node2Id];\n        \n        const newX = (node1.x + node2.x) / 2;\n        const newY = Math.max(node1.y, node2.y) + random(0.1, 1.5);\n\n        const newNodeId = mergeCount++;\n        nodes[newNodeId] = { x: newX, y: newY };\n\n        links.push({ source: node1, target: { x: node1.x, y: newY }, distance: newY });\n        links.push({ source: node2, target: { x: node2.x, y: newY }, distance: newY });\n        links.push({ source: { x: node1.x, y: newY }, target: { x: node2.x, y: newY }, distance: newY });\n\n        availableNodes.push(newNodeId);\n    }\n\n    return { \n        links, \n        nodes: Object.values(nodes),\n        cluster_threshold: clusterThreshold\n    };\n};\n\n\nexport const simulateClustering = (params: SimulationParams): ClusteringResults => {\n  const { dataset, nClusters, features } = params;\n  const datasetInfo = DATASETS[dataset];\n\n  const n_samples = dataset === 'iris' ? 150 : dataset === 'wine' ? 178 : 357;\n  const usedFeatures = features.length > 0 ? features : datasetInfo.features;\n  const n_features = usedFeatures.length;\n\n  const scatter_data_2d = generateScatterData(n_samples, nClusters, n_features);\n  const cluster_labels = scatter_data_2d.map(p => p.cluster);\n  \n  const cluster_summary: ClusteringResults['cluster_summary'] = Array.from({ length: nClusters }, (_, i) => ({\n    clusterId: i,\n    nSamples: cluster_labels.filter(l => l === i).length,\n    featureMeans: usedFeatures.reduce((acc, feature) => {\n      acc[feature] = random(0, 10);\n      return acc;\n    }, {} as Record<string, number>),\n    representativeSampleIndices: Array.from({ length: 3 }, () => randomInt(0, n_samples)),\n  }));\n\n  const silhouette_scores: ClusteringResults['silhouette_scores'] = Array.from({ length: nClusters }, (_, i) => ({\n    cluster: `Cluster ${i}`,\n    score: random(0.1, 0.9),\n  }));\n\n  const cluster_heatmap: ClusteringResults['cluster_heatmap'] = {\n    features: usedFeatures.slice(0, 5),\n    cluster_data: Array.from({ length: nClusters }, (_, i) => ({\n      cluster: `Cluster ${i}`,\n      ...usedFeatures.slice(0, 5).reduce((acc, feature) => {\n        acc[feature] = random(0, 1);\n        return acc;\n      }, {} as Record<string, number>),\n    })),\n  };\n\n  const feature_correlation: ClusteringResults['feature_correlation'] = {\n    features: usedFeatures.slice(0, 8),\n    matrix: Array.from({ length: 8 }, (_, i) => \n      Array.from({ length: 8 }, (_, j) => i === j ? 1 : random(-1, 1))\n    ),\n  };\n\n  const feature_distributions: ClusteringResults['feature_distributions'] = usedFeatures.slice(0, 4).map(feature => ({\n    feature,\n    bins: Array.from({ length: 10 }, (_, i) => ({\n      name: `${i * 10}-${(i + 1) * 10}`,\n      value: randomInt(5, 50),\n    })),\n  }));\n\n  const target_distribution = dataset === 'iris' ? \n  [{name: 'Setosa', value: 50}, {name: 'Versicolour', value: 50}, {name: 'Virginica', value: 50}] :\n  dataset === 'wine' ?\n  [{name: 'Class 0', value: 59}, {name: 'Class 1', value: 71}, {name: 'Class 2', value: 48}] :\n  [];\n\n\n  return {\n    dataset_summary: {\n      n_samples,\n      n_features,\n      feature_names: datasetInfo.features,\n      description: datasetInfo.description,\n      target_distribution,\n    },\n    dendrogram: generateDendrogramData(50, nClusters), // Use subset for dendrogram clarity\n    scatter_data_2d,\n    cluster_labels,\n    silhouette_scores,\n    cluster_summary,\n    cluster_heatmap,\n    feature_correlation,\n    feature_distributions,\n  };\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/lib/actions.ts"],"sourcesContent":["\"use server\";\n\nimport { ClusteringResults } from \"@/types\";\nimport { simulateClustering } from \"./clustering-simulation\";\nimport { DATASETS } from \"./datasets\";\n\ntype ClusteringParams = {\n  dataset: keyof typeof DATASETS;\n  nClusters: number;\n  linkage: string;\n  metric: string;\n  features: string[];\n};\n\nexport async function performClustering(\n  params: ClusteringParams\n): Promise<ClusteringResults> {\n  try {\n    // Artificial delay to simulate computation\n    await new Promise((resolve) => setTimeout(resolve, 1500));\n\n    const results = simulateClustering(params);\n    return results;\n  } catch (error) {\n    console.error(\"Error during clustering simulation:\", error);\n    throw new Error(\"Failed to perform clustering.\");\n  }\n}\n"],"names":[],"mappings":";;;;;AAGA;;;;;AAWO,eAAe,kBACpB,MAAwB;IAExB,IAAI;QACF,2CAA2C;QAC3C,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;QAEnD,MAAM,UAAU,CAAA,GAAA,6IAAA,CAAA,qBAAkB,AAAD,EAAE;QACnC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,MAAM,IAAI,MAAM;IAClB;AACF;;;IAbsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 628, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/google-genai';\n\nexport const ai = genkit({\n  plugins: [\n    googleAI({\n      apiKey: process.env.GEMINI_API_KEY,\n    }),\n  ],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QACP,CAAA,GAAA,6KAAA,CAAA,WAAQ,AAAD,EAAE;YACP,QAAQ,QAAQ,GAAG,CAAC,cAAc;QACpC;KACD;IACD,OAAO;AACT","debugId":null}},
    {"offset": {"line": 651, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-cluster-insights.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview This file defines a Genkit flow for generating cluster insights.\n *\n * - generateClusterInsights - An async function that takes cluster data and returns a summary of insights.\n * - ClusterInsightsInput - The input type for the generateClusterInsights function.\n * - ClusterInsightsOutput - The output type for the generateClusterInsights function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'zod';\n\n// Define the input schema for the flow\nconst ClusterInsightsInputSchema = z.object({\n  clusterData: z.array(\n    z.object({\n      clusterId: z.number(),\n      nSamples: z.number(),\n      featureMeans: z.record(z.string(), z.number()),\n      representativeSampleIndices: z.array(z.number()),\n    })\n  ).describe('Array of cluster data, each containing cluster ID, number of samples, feature means, and representative sample indices.'),\n  datasetDescription: z.string().describe('Description of the dataset used for clustering.'),\n});\nexport type ClusterInsightsInput = z.infer<typeof ClusterInsightsInputSchema>;\n\n// Define the output schema for the flow\nconst ClusterInsightsOutputSchema = z.object({\n  insights: z.array(\n    z.object({\n      clusterId: z.number(),\n      summary: z.string(),\n    })\n  ).describe('Array of cluster insights, each containing the cluster ID and a summary of its key characteristics.'),\n});\nexport type ClusterInsightsOutput = z.infer<typeof ClusterInsightsOutputSchema>;\n\n// Define the prompt\nconst clusterInsightsPrompt = ai.definePrompt({\n  name: 'clusterInsightsPrompt',\n  input: {schema: ClusterInsightsInputSchema},\n  output: {schema: ClusterInsightsOutputSchema},\n  prompt: `You are an expert data scientist. You are given data about clusters formed from a dataset, and your task is to summarize the key characteristics of each cluster.\n\nDataset Description: {{{datasetDescription}}}\n\nFor each cluster, you should highlight the features that distinguish it from the other clusters, mentioning the mean values and variance if applicable. Also, mention representative samples for each cluster to provide concrete examples.\n\nHere is the cluster data:\n\n{{#each clusterData}}\n  Cluster ID: {{clusterId}}\n  Number of Samples: {{nSamples}}\n  Feature Means:\n  {{#each featureMeans}}\n    - {{@key}}: {{this}}\n  {{/each}}\n  Representative Sample Indices: {{representativeSampleIndices}}\n{{/each}}\n\nGenerate a concise summary for each cluster that highlights its key characteristics and distinguishing features. Return the answer in JSON format.\n`,\n});\n\n// Define the flow\nconst generateClusterInsightsFlow = ai.defineFlow(\n  {\n    name: 'generateClusterInsightsFlow',\n    inputSchema: ClusterInsightsInputSchema,\n    outputSchema: ClusterInsightsOutputSchema,\n  },\n  async input => {\n    const {output} = await clusterInsightsPrompt(input);\n    return output!;\n  }\n);\n\n/**\n * Generates cluster insights by calling the generateClusterInsightsFlow.\n * @param input - The input data for generating cluster insights.\n * @returns A promise that resolves to the cluster insights.\n */\nexport async function generateClusterInsights(input: ClusterInsightsInput): Promise<ClusterInsightsOutput> {\n  return generateClusterInsightsFlow(input);\n}\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;;;;;;AAEA,uCAAuC;AACvC,MAAM,6BAA6B,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,aAAa,oIAAA,CAAA,IAAC,CAAC,KAAK,CAClB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,WAAW,oIAAA,CAAA,IAAC,CAAC,MAAM;QACnB,UAAU,oIAAA,CAAA,IAAC,CAAC,MAAM;QAClB,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,oIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,oIAAA,CAAA,IAAC,CAAC,MAAM;QAC3C,6BAA6B,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,oIAAA,CAAA,IAAC,CAAC,MAAM;IAC/C,IACA,QAAQ,CAAC;IACX,oBAAoB,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC1C;AAGA,wCAAwC;AACxC,MAAM,8BAA8B,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,UAAU,oIAAA,CAAA,IAAC,CAAC,KAAK,CACf,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,WAAW,oIAAA,CAAA,IAAC,CAAC,MAAM;QACnB,SAAS,oIAAA,CAAA,IAAC,CAAC,MAAM;IACnB,IACA,QAAQ,CAAC;AACb;AAGA,oBAAoB;AACpB,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC5C,MAAM;IACN,OAAO;QAAC,QAAQ;IAA0B;IAC1C,QAAQ;QAAC,QAAQ;IAA2B;IAC5C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;AAmBX,CAAC;AACD;AAEA,kBAAkB;AAClB,MAAM,8BAA8B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC/C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,sBAAsB;IAC7C,OAAO;AACT;AAQK,eAAe,wBAAwB,KAA2B;IACvE,OAAO,4BAA4B;AACrC;;;IAFsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 739, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/dashboard/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {performClustering as '40e695065d7769a5f70534f8f13f242cd90b2a3208'} from 'ACTIONS_MODULE0'\nexport {generateClusterInsights as '403a1db0e5b0d835b30cbaffe1dcd2e01735acb084'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA","debugId":null}},
    {"offset": {"line": 797, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/dashboard.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Dashboard = registerClientReference(\n    function() { throw new Error(\"Attempted to call Dashboard() from the server but Dashboard is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/dashboard.tsx <module evaluation>\",\n    \"Dashboard\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,YAAY,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAkO,GAC/P,8DACA","debugId":null}},
    {"offset": {"line": 811, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/dashboard.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Dashboard = registerClientReference(\n    function() { throw new Error(\"Attempted to call Dashboard() from the server but Dashboard is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/dashboard.tsx\",\n    \"Dashboard\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,YAAY,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAkO,GAC/P,0CACA","debugId":null}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 835, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/dashboard/page.tsx"],"sourcesContent":["import { Dashboard } from '@/components/dashboard';\n\nexport default function DashboardPage() {\n  return (\n    <Dashboard />\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS;IACtB,qBACE,8OAAC,+HAAA,CAAA,YAAS;;;;;AAEd","debugId":null}}]
}